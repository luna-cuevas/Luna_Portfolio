{"ast":null,"code":"/*!\n * MotionPathPlugin 3.8.0\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nimport { getRawPath, cacheRawPathMeasurements, getPositionOnPath, pointsToSegment, flatPointsToSegment, sliceRawPath, stringToRawPath, rawPathToString, transformRawPath, convertToPath } from \"./utils/paths.js\";\nimport { getGlobalMatrix } from \"./utils/matrix.js\";\n\nlet _xProps = \"x,translateX,left,marginLeft,xPercent\".split(\",\"),\n    _yProps = \"y,translateY,top,marginTop,yPercent\".split(\",\"),\n    _DEG2RAD = Math.PI / 180,\n    gsap,\n    PropTween,\n    _getUnit,\n    _toArray,\n    _getGSAP = () => gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n    _populateSegmentFromArray = (segment, values, property, mode) => {\n  //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.\n  let l = values.length,\n      si = mode === 2 ? 0 : mode,\n      i = 0,\n      v;\n\n  for (; i < l; i++) {\n    segment[si] = v = parseFloat(values[i][property]);\n    mode === 2 && (segment[si + 1] = 0);\n    si += 2;\n  }\n\n  return segment;\n},\n    _getPropNum = (target, prop, unit) => parseFloat(target._gsap.get(target, prop, unit || \"px\")) || 0,\n    _relativize = segment => {\n  let x = segment[0],\n      y = segment[1],\n      i;\n\n  for (i = 2; i < segment.length; i += 2) {\n    x = segment[i] += x;\n    y = segment[i + 1] += y;\n  }\n},\n    // feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier\n// _quadToCubic = points => {\n// \tlet cubic = [],\n// \t\tl = points.length - 1,\n// \t\ti = 1,\n// \t\ta, b, c;\n// \tfor (; i < l; i+=2) {\n// \t\ta = points[i-1];\n// \t\tb = points[i];\n// \t\tc = points[i+1];\n// \t\tcubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});\n// \t}\n// \tcubic.push(points[l]);\n// \treturn cubic;\n// },\n_segmentToRawPath = (plugin, segment, target, x, y, slicer, vars, unitX, unitY) => {\n  if (vars.type === \"cubic\") {\n    segment = [segment];\n  } else {\n    vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\n    vars.relative && _relativize(segment);\n    let pointFunc = y ? pointsToSegment : flatPointsToSegment;\n    segment = [pointFunc(segment, vars.curviness)];\n  }\n\n  segment = slicer(_align(segment, target, vars));\n\n  _addDimensionalPropTween(plugin, target, x, segment, \"x\", unitX);\n\n  y && _addDimensionalPropTween(plugin, target, y, segment, \"y\", unitY);\n  return cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.\n},\n    _emptyFunc = v => v,\n    _numExp = /[-+\\.]*\\d+\\.?(?:e-|e\\+)?\\d*/g,\n    _originToPoint = (element, origin, parentMatrix) => {\n  // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be \"auto\" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.\n  let m = getGlobalMatrix(element),\n      x = 0,\n      y = 0,\n      svg;\n\n  if ((element.tagName + \"\").toLowerCase() === \"svg\") {\n    svg = element.viewBox.baseVal;\n    svg.width || (svg = {\n      width: +element.getAttribute(\"width\"),\n      height: +element.getAttribute(\"height\")\n    });\n  } else {\n    svg = origin && element.getBBox && element.getBBox();\n  }\n\n  if (origin && origin !== \"auto\") {\n    x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\n    y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\n  }\n\n  return parentMatrix.apply(x || y ? m.apply({\n    x: x,\n    y: y\n  }) : {\n    x: m.e,\n    y: m.f\n  });\n},\n    _getAlignMatrix = (fromElement, toElement, fromOrigin, toOrigin) => {\n  let parentMatrix = getGlobalMatrix(fromElement.parentNode, true, true),\n      m = parentMatrix.clone().multiply(getGlobalMatrix(toElement)),\n      fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),\n      {\n    x,\n    y\n  } = _originToPoint(toElement, toOrigin, parentMatrix),\n      p;\n\n  m.e = m.f = 0;\n\n  if (toOrigin === \"auto\" && toElement.getTotalLength && toElement.tagName.toLowerCase() === \"path\") {\n    p = toElement.getAttribute(\"d\").match(_numExp) || [];\n    p = m.apply({\n      x: +p[0],\n      y: +p[1]\n    });\n    x += p.x;\n    y += p.y;\n  }\n\n  if (p || toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement) {\n    p = m.apply(toElement.getBBox());\n    x -= p.x;\n    y -= p.y;\n  }\n\n  m.e = x - fromPoint.x;\n  m.f = y - fromPoint.y;\n  return m;\n},\n    _align = (rawPath, target, {\n  align,\n  matrix,\n  offsetX,\n  offsetY,\n  alignOrigin\n}) => {\n  let x = rawPath[0][0],\n      y = rawPath[0][1],\n      curX = _getPropNum(target, \"x\"),\n      curY = _getPropNum(target, \"y\"),\n      alignTarget,\n      m,\n      p;\n\n  if (!rawPath || !rawPath.length) {\n    return getRawPath(\"M0,0L0,0\");\n  }\n\n  if (align) {\n    if (align === \"self\" || (alignTarget = _toArray(align)[0] || target) === target) {\n      transformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y);\n    } else {\n      if (alignOrigin && alignOrigin[2] !== false) {\n        gsap.set(target, {\n          transformOrigin: alignOrigin[0] * 100 + \"% \" + alignOrigin[1] * 100 + \"%\"\n        });\n      } else {\n        alignOrigin = [_getPropNum(target, \"xPercent\") / -100, _getPropNum(target, \"yPercent\") / -100];\n      }\n\n      m = _getAlignMatrix(target, alignTarget, alignOrigin, \"auto\");\n      p = m.apply({\n        x: x,\n        y: y\n      });\n      transformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\n    }\n  }\n\n  if (matrix) {\n    transformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n  } else if (offsetX || offsetY) {\n    transformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\n  }\n\n  return rawPath;\n},\n    _addDimensionalPropTween = (plugin, target, property, rawPath, pathProperty, forceUnit) => {\n  let cache = target._gsap,\n      harness = cache.harness,\n      alias = harness && harness.aliases && harness.aliases[property],\n      prop = alias && alias.indexOf(\",\") < 0 ? alias : property,\n      pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\n  pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\n  pt.path = rawPath;\n  pt.pp = pathProperty;\n\n  plugin._props.push(prop);\n},\n    _sliceModifier = (start, end) => rawPath => start || end !== 1 ? sliceRawPath(rawPath, start, end) : rawPath;\n\nexport const MotionPathPlugin = {\n  version: \"3.8.0\",\n  name: \"motionPath\",\n\n  register(core, Plugin, propTween) {\n    gsap = core;\n    _getUnit = gsap.utils.getUnit;\n    _toArray = gsap.utils.toArray;\n    PropTween = propTween;\n  },\n\n  init(target, vars) {\n    if (!gsap) {\n      console.warn(\"Please gsap.registerPlugin(MotionPathPlugin)\");\n      return false;\n    }\n\n    if (!(typeof vars === \"object\" && !vars.style) || !vars.path) {\n      vars = {\n        path: vars\n      };\n    }\n\n    let rawPaths = [],\n        {\n      path,\n      autoRotate,\n      unitX,\n      unitY,\n      x,\n      y\n    } = vars,\n        firstObj = path[0],\n        slicer = _sliceModifier(vars.start, \"end\" in vars ? vars.end : 1),\n        rawPath,\n        p;\n\n    this.rawPaths = rawPaths;\n    this.target = target;\n\n    if (this.rotate = autoRotate || autoRotate === 0) {\n      //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.\n      this.rOffset = parseFloat(autoRotate) || 0;\n      this.radians = !!vars.useRadians;\n      this.rProp = vars.rotation || \"rotation\"; // rotation property\n\n      this.rSet = target._gsap.set(target, this.rProp, this); // rotation setter\n\n      this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0; // rotation units\n    }\n\n    if (Array.isArray(path) && !(\"closed\" in path) && typeof firstObj !== \"number\") {\n      for (p in firstObj) {\n        if (!x && ~_xProps.indexOf(p)) {\n          x = p;\n        } else if (!y && ~_yProps.indexOf(p)) {\n          y = p;\n        }\n      }\n\n      if (x && y) {\n        //correlated values\n        rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\n      } else {\n        x = y = 0;\n      }\n\n      for (p in firstObj) {\n        p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\n      }\n    } else {\n      rawPath = slicer(_align(getRawPath(vars.path), target, vars));\n      cacheRawPathMeasurements(rawPath, vars.resolution);\n      rawPaths.push(rawPath);\n\n      _addDimensionalPropTween(this, target, vars.x || \"x\", rawPath, \"x\", vars.unitX || \"px\");\n\n      _addDimensionalPropTween(this, target, vars.y || \"y\", rawPath, \"y\", vars.unitY || \"px\");\n    }\n  },\n\n  render(ratio, data) {\n    let rawPaths = data.rawPaths,\n        i = rawPaths.length,\n        pt = data._pt;\n\n    if (ratio > 1) {\n      ratio = 1;\n    } else if (ratio < 0) {\n      ratio = 0;\n    }\n\n    while (i--) {\n      getPositionOnPath(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\n    }\n\n    while (pt) {\n      pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\n      pt = pt._next;\n    }\n\n    data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);\n  },\n\n  getLength(path) {\n    return cacheRawPathMeasurements(getRawPath(path)).totalLength;\n  },\n\n  sliceRawPath,\n  getRawPath,\n  pointsToSegment,\n  stringToRawPath,\n  rawPathToString,\n  transformRawPath,\n  getGlobalMatrix,\n  getPositionOnPath,\n  cacheRawPathMeasurements,\n  convertToPath: (targets, swap) => _toArray(targets).map(target => convertToPath(target, swap !== false)),\n\n  convertCoordinates(fromElement, toElement, point) {\n    let m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));\n    return point ? m.apply(point) : m;\n  },\n\n  getAlignMatrix: _getAlignMatrix,\n\n  getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\n    let m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\n\n    return {\n      x: m.e,\n      y: m.f\n    };\n  },\n\n  arrayToRawPath(value, vars) {\n    vars = vars || {};\n\n    let segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || \"x\", 0), value, vars.y || \"y\", 1);\n\n    vars.relative && _relativize(segment);\n    return [vars.type === \"cubic\" ? segment : pointsToSegment(segment, vars.curviness)];\n  }\n\n};\n_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\nexport { MotionPathPlugin as default };","map":{"version":3,"sources":["/Users/luna.c/Documents/code/Luna_Portfolio/node_modules/gsap/src/MotionPathPlugin.js"],"names":["getRawPath","cacheRawPathMeasurements","getPositionOnPath","pointsToSegment","flatPointsToSegment","sliceRawPath","stringToRawPath","rawPathToString","transformRawPath","convertToPath","getGlobalMatrix","_xProps","split","_yProps","_DEG2RAD","Math","PI","gsap","PropTween","_getUnit","_toArray","_getGSAP","window","registerPlugin","_populateSegmentFromArray","segment","values","property","mode","l","length","si","i","v","parseFloat","_getPropNum","target","prop","unit","_gsap","get","_relativize","x","y","_segmentToRawPath","plugin","slicer","vars","unitX","unitY","type","fromCurrent","unshift","relative","pointFunc","curviness","_align","_addDimensionalPropTween","resolution","_emptyFunc","_numExp","_originToPoint","element","origin","parentMatrix","m","svg","tagName","toLowerCase","viewBox","baseVal","width","getAttribute","height","getBBox","push","offsetWidth","offsetHeight","apply","e","f","_getAlignMatrix","fromElement","toElement","fromOrigin","toOrigin","parentNode","clone","multiply","fromPoint","p","getTotalLength","match","ownerSVGElement","rawPath","align","matrix","offsetX","offsetY","alignOrigin","curX","curY","alignTarget","set","transformOrigin","a","b","c","d","pathProperty","forceUnit","cache","harness","alias","aliases","indexOf","pt","_pt","u","path","pp","_props","_sliceModifier","start","end","MotionPathPlugin","version","name","register","core","Plugin","propTween","utils","getUnit","toArray","init","console","warn","style","rawPaths","autoRotate","firstObj","rotate","rOffset","radians","useRadians","rProp","rotation","rSet","ru","Array","isArray","render","ratio","data","t","_next","angle","getLength","totalLength","targets","swap","map","convertCoordinates","point","getAlignMatrix","getRelativePosition","arrayToRawPath","value","default"],"mappings":"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","sourcesContent":["/*!\n * MotionPathPlugin 3.8.0\n * https://greensock.com\n *\n * @license Copyright 2008-2021, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nimport { getRawPath, cacheRawPathMeasurements, getPositionOnPath, pointsToSegment, flatPointsToSegment, sliceRawPath, stringToRawPath, rawPathToString, transformRawPath, convertToPath } from \"./utils/paths.js\";\nimport { getGlobalMatrix } from \"./utils/matrix.js\";\n\nlet _xProps = \"x,translateX,left,marginLeft,xPercent\".split(\",\"),\n\t_yProps = \"y,translateY,top,marginTop,yPercent\".split(\",\"),\n\t_DEG2RAD = Math.PI / 180,\n\tgsap, PropTween, _getUnit, _toArray,\n\t_getGSAP = () => gsap || (typeof(window) !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap),\n\t_populateSegmentFromArray = (segment, values, property, mode) => { //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.\n\t\tlet l = values.length,\n\t\t\tsi = mode === 2 ? 0 : mode,\n\t\t\ti = 0,\n\t\t\tv;\n\t\tfor (; i < l; i++) {\n\t\t\tsegment[si] = v = parseFloat(values[i][property]);\n\t\t\tmode === 2 && (segment[si+1] = 0);\n\t\t\tsi += 2;\n\t\t}\n\t\treturn segment;\n\t},\n\t_getPropNum = (target, prop, unit) => parseFloat(target._gsap.get(target, prop, unit || \"px\")) || 0,\n\t_relativize = segment => {\n\t\tlet x = segment[0],\n\t\t\ty = segment[1],\n\t\t\ti;\n\t\tfor (i = 2; i < segment.length; i+=2) {\n\t\t\tx = (segment[i] += x);\n\t\t\ty = (segment[i+1] += y);\n\t\t}\n\t},\n\t// feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier\n\t// _quadToCubic = points => {\n\t// \tlet cubic = [],\n\t// \t\tl = points.length - 1,\n\t// \t\ti = 1,\n\t// \t\ta, b, c;\n\t// \tfor (; i < l; i+=2) {\n\t// \t\ta = points[i-1];\n\t// \t\tb = points[i];\n\t// \t\tc = points[i+1];\n\t// \t\tcubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});\n\t// \t}\n\t// \tcubic.push(points[l]);\n\t// \treturn cubic;\n\t// },\n\t_segmentToRawPath = (plugin, segment, target, x, y, slicer, vars, unitX, unitY) => {\n\t\tif (vars.type === \"cubic\") {\n\t\t\tsegment = [segment];\n\t\t} else {\n\t\t\tvars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\n\t\t\tvars.relative && _relativize(segment);\n\t\t\tlet pointFunc = y ? pointsToSegment : flatPointsToSegment;\n\t\t\tsegment = [pointFunc(segment, vars.curviness)];\n\t\t}\n\t\tsegment = slicer(_align(segment, target, vars));\n\t\t_addDimensionalPropTween(plugin, target, x, segment, \"x\", unitX);\n\t\ty && _addDimensionalPropTween(plugin, target, y, segment, \"y\", unitY);\n\t\treturn cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.\n\t},\n\t_emptyFunc = v => v,\n\t_numExp = /[-+\\.]*\\d+\\.?(?:e-|e\\+)?\\d*/g,\n\t_originToPoint = (element, origin, parentMatrix) => { // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be \"auto\" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.\n\t\tlet m = getGlobalMatrix(element),\n\t\t\tx = 0,\n\t\t\ty = 0,\n\t\t\tsvg;\n\t\tif ((element.tagName + \"\").toLowerCase() === \"svg\") {\n\t\t\tsvg = element.viewBox.baseVal;\n\t\t\tsvg.width || (svg = {width: +element.getAttribute(\"width\"), height: +element.getAttribute(\"height\")});\n\t\t} else {\n\t\t\tsvg = origin && element.getBBox && element.getBBox();\n\t\t}\n\t\tif (origin && origin !== \"auto\") {\n\t\t\tx = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\n\t\t\ty = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\n\t\t}\n\t\treturn parentMatrix.apply( x || y ? m.apply({x: x, y: y}) : {x: m.e, y: m.f} );\n\t},\n\t_getAlignMatrix = (fromElement, toElement, fromOrigin, toOrigin) => {\n\t\tlet parentMatrix = getGlobalMatrix(fromElement.parentNode, true, true),\n\t\t\tm = parentMatrix.clone().multiply(getGlobalMatrix(toElement)),\n\t\t\tfromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),\n\t\t\t{x, y} = _originToPoint(toElement, toOrigin, parentMatrix),\n\t\t\tp;\n\t\tm.e = m.f = 0;\n\t\tif (toOrigin === \"auto\" && toElement.getTotalLength && toElement.tagName.toLowerCase() === \"path\") {\n\t\t\tp = toElement.getAttribute(\"d\").match(_numExp) || [];\n\t\t\tp = m.apply({x:+p[0], y:+p[1]});\n\t\t\tx += p.x;\n\t\t\ty += p.y;\n\t\t}\n\t\tif (p || (toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement)) {\n\t\t\tp = m.apply(toElement.getBBox());\n\t\t\tx -= p.x;\n\t\t\ty -= p.y;\n\t\t}\n\t\tm.e = x - fromPoint.x;\n\t\tm.f = y - fromPoint.y;\n\t\treturn m;\n\t},\n\t_align = (rawPath, target, {align, matrix, offsetX, offsetY, alignOrigin}) => {\n\t\tlet x = rawPath[0][0],\n\t\t\ty = rawPath[0][1],\n\t\t\tcurX = _getPropNum(target, \"x\"),\n\t\t\tcurY = _getPropNum(target, \"y\"),\n\t\t\talignTarget, m, p;\n\t\tif (!rawPath || !rawPath.length) {\n\t\t\treturn getRawPath(\"M0,0L0,0\");\n\t\t}\n\t\tif (align) {\n\t\t\tif (align === \"self\" || ((alignTarget = _toArray(align)[0] || target) === target)) {\n\t\t\t\ttransformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y);\n\t\t\t} else {\n\t\t\t\tif (alignOrigin && alignOrigin[2] !== false) {\n\t\t\t\t\tgsap.set(target, {transformOrigin:(alignOrigin[0] * 100) + \"% \" + (alignOrigin[1] * 100) + \"%\"});\n\t\t\t\t} else {\n\t\t\t\t\talignOrigin = [_getPropNum(target, \"xPercent\") / -100, _getPropNum(target, \"yPercent\") / -100];\n\t\t\t\t}\n\t\t\t\tm = _getAlignMatrix(target, alignTarget, alignOrigin, \"auto\");\n\t\t\t\tp = m.apply({x: x, y: y});\n\t\t\t\ttransformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\n\t\t\t}\n\t\t}\n\t\tif (matrix) {\n\t\t\ttransformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n\t\t} else if (offsetX || offsetY) {\n\t\t\ttransformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\n\t\t}\n\t\treturn rawPath;\n\t},\n\t_addDimensionalPropTween = (plugin, target, property, rawPath, pathProperty, forceUnit) => {\n\t\tlet cache = target._gsap,\n\t\t\tharness = cache.harness,\n\t\t\talias = (harness && harness.aliases && harness.aliases[property]),\n\t\t\tprop = alias && alias.indexOf(\",\") < 0 ? alias : property,\n\t\t\tpt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\n\t\tpt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\n\t\tpt.path = rawPath;\n\t\tpt.pp = pathProperty;\n\t\tplugin._props.push(prop);\n\t},\n\t_sliceModifier = (start, end) => rawPath => (start || end !== 1) ? sliceRawPath(rawPath, start, end) : rawPath;\n\n\nexport const MotionPathPlugin = {\n\tversion: \"3.8.0\",\n\tname: \"motionPath\",\n\tregister(core, Plugin, propTween) {\n\t\tgsap = core;\n\t\t_getUnit = gsap.utils.getUnit;\n\t\t_toArray = gsap.utils.toArray;\n\t\tPropTween = propTween;\n\t},\n\tinit(target, vars) {\n\t\tif (!gsap) {\n\t\t\tconsole.warn(\"Please gsap.registerPlugin(MotionPathPlugin)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!(typeof(vars) === \"object\" && !vars.style) || !vars.path) {\n\t\t\tvars = {path:vars};\n\t\t}\n\t\tlet rawPaths = [],\n\t\t\t{path, autoRotate, unitX, unitY, x, y} = vars,\n\t\t\tfirstObj = path[0],\n\t\t\tslicer = _sliceModifier(vars.start, (\"end\" in vars) ? vars.end : 1),\n\t\t\trawPath, p;\n\t\tthis.rawPaths = rawPaths;\n\t\tthis.target = target;\n\t\tif ((this.rotate = (autoRotate || autoRotate === 0))) { //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.\n\t\t\tthis.rOffset = parseFloat(autoRotate) || 0;\n\t\t\tthis.radians = !!vars.useRadians;\n\t\t\tthis.rProp = vars.rotation || \"rotation\";                       // rotation property\n\t\t\tthis.rSet = target._gsap.set(target, this.rProp, this);         // rotation setter\n\t\t\tthis.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0;  // rotation units\n\t\t}\n\t\tif (Array.isArray(path) && !(\"closed\" in path) && typeof(firstObj) !== \"number\") {\n\t\t\tfor (p in firstObj) {\n\t\t\t\tif (!x && ~_xProps.indexOf(p)) {\n\t\t\t\t\tx = p;\n\t\t\t\t} else if (!y && ~_yProps.indexOf(p)) {\n\t\t\t\t\ty = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x && y) { //correlated values\n\t\t\t\trawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\n\t\t\t} else {\n\t\t\t\tx = y = 0;\n\t\t\t}\n\t\t\tfor (p in firstObj) {\n\t\t\t\tp !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\n\t\t\t}\n\t\t} else {\n\t\t\trawPath = slicer(_align(getRawPath(vars.path), target, vars));\n\t\t\tcacheRawPathMeasurements(rawPath, vars.resolution);\n\t\t\trawPaths.push(rawPath);\n\t\t\t_addDimensionalPropTween(this, target, vars.x || \"x\", rawPath, \"x\", vars.unitX || \"px\");\n\t\t\t_addDimensionalPropTween(this, target, vars.y || \"y\", rawPath, \"y\", vars.unitY || \"px\");\n\t\t}\n\t},\n\trender(ratio, data) {\n\t\tlet rawPaths = data.rawPaths,\n\t\t\ti = rawPaths.length,\n\t\t\tpt = data._pt;\n\t\tif (ratio > 1) {\n\t\t\tratio = 1;\n\t\t} else if (ratio < 0) {\n\t\t\tratio = 0;\n\t\t}\n\t\twhile (i--) {\n\t\t\tgetPositionOnPath(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\n\t\t}\n\t\twhile (pt) {\n\t\t\tpt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\n\t\t\tpt = pt._next;\n\t\t}\n\t\tdata.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);\n\t},\n\tgetLength(path) {\n\t\treturn cacheRawPathMeasurements(getRawPath(path)).totalLength;\n\t},\n\tsliceRawPath,\n\tgetRawPath,\n\tpointsToSegment,\n\tstringToRawPath,\n\trawPathToString,\n\ttransformRawPath,\n\tgetGlobalMatrix,\n\tgetPositionOnPath,\n\tcacheRawPathMeasurements,\n\tconvertToPath: (targets, swap) => _toArray(targets).map(target => convertToPath(target, swap !== false)),\n\tconvertCoordinates(fromElement, toElement, point) {\n\t\tlet m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));\n\t\treturn point ? m.apply(point) : m;\n\t},\n\tgetAlignMatrix: _getAlignMatrix,\n\tgetRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\n\t\tlet m =_getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\n\t\treturn {x: m.e, y: m.f};\n\t},\n\tarrayToRawPath(value, vars) {\n\t\tvars = vars || {};\n\t\tlet segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || \"x\", 0), value, vars.y || \"y\", 1);\n\t\tvars.relative && _relativize(segment);\n\t\treturn [(vars.type === \"cubic\") ? segment : pointsToSegment(segment, vars.curviness)];\n\t}\n};\n\n_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\n\nexport { MotionPathPlugin as default };"]},"metadata":{},"sourceType":"module"}